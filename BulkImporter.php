<?php

namespace Ibrows\ImportBundle;

use Ibrows\ImportBundle\Exception\MethodNotFoundException;
use Ibrows\ImportBundle\Generator\ImportHashGenerator;
use Ibrows\ImportBundle\Row\RowInterface;

abstract class BulkImporter extends AbstractImporter
{
    protected $identifiers = array();
    protected $identifiersClass = '';
    protected $inserts = array();
    protected $updates = array();
    protected $processedInsertIds = array();
    protected $processedUpdateIds = array();
    protected $dbIdentifier = 'id';
    protected $dbIdentifierGetter = 'getId';
    protected $alias = 'e';
    protected $stepSize = 0;
    /**
     * @var ImportHashGenerator
     */
    protected $importHashGenerator;

    function __construct($importHashGenerator)
    {
        $this->importHashGenerator = $importHashGenerator;
    }

    protected function importRow($index, $row, $className)
    {
        $builtEntity = $this->buildEntity($index, $row, new $className());
        $arr = $this->getAlreadyExisting($builtEntity);
        if($arr){
            $this->update($builtEntity, $arr[$this->getDbIdentifier()]);
        }else{
            $this->insert($builtEntity);
        }
    }

    protected function buildEntity($key, RowInterface $row, $entity, $fromAlreadyExisting = false)
    {
        $entity = parent::buildEntity($key, $row, $entity, $fromAlreadyExisting); // TODO: Change the autogenerated stub
        $hash = null;
        if( $this->importHashGenerator  != null )
        {
            $hash = $this->importHashGenerator->generateFromEntity($entity);
        }

        if($entity instanceof ImportableEntityInterface){
            $entity->setImportHash($hash);
        }

        return $entity;
    }

    public function resetIdentifier(){
        $this->processedInsertIds = array();
        $this->processedUpdateIds = array();
        $this->identifiers = array();
        $this->identifiersClass = '';
    }

    /**
     * @return array
     */
    public function getProcessedInsertIds()
    {
        return $this->processedInsertIds;
    }

    /**
     * @return array
     */
    public function getProcessedUpdateIds()
    {
        return $this->processedUpdateIds;
    }



    public function flush(){
        $this->flushUpdates();
        $this->flushInserts();
    }

    protected function update($entity, $id){
        $this->updates[$id] = $entity;
        if($this->getStepSize() !== 0 && sizeof($this->updates)>=$this->getStepSize()){
            $this->flushUpdates();
        }
    }

    protected function flushUpdates(){

        $current = current($this->updates);
        if(!$current){
            return false;
        }
        $updated = 0;
        $class = get_class($current);
        $ids = array_keys($this->updates);
        $existingEntities = $this->entityManager->getRepository($class)->findBy(array('id'=>$ids));
        $hasChanges = false;

        foreach($existingEntities as $entity){
            $method = $this->getDbIdentifierGetter();
            $id = $entity->$method();
            if($this->checkForUpdates($entity, $this->updates[$id])){
                $merged = $this->merge($entity,  $this->updates[$id]);
                if($this->isImportableEntity($merged) && $this->isImportableEntity($this->updates[$id])){
                    $merged->setUpdatedAt(new \DateTime());
                    $merged->setImportHash( $this->importHashGenerator->generateFromEntity($merged) );
                }
                $this->entityManager->persist($merged);
                $this->processedUpdateIds[$id] = $id;
                $hasChanges = true;
                $updated++;
            }
        }

        if($hasChanges ){
            $this->entityManager->flush();
        }

        $this->entityManager->clear();
        $this->updates = array();
        return $updated;
    }

    protected function isImportableEntity($entity){
        return ($entity instanceof ImportableEntityInterface);
    }

    protected function checkForUpdates($entity, $update){
        if( $this->isImportableEntity($entity) && $this->isImportableEntity($update)){
            if($entity->getImportHash() == $update->getImportHash() && $entity->getImportHash() == $this->importHashGenerator->generateFromEntity($entity)){
                return false;
            }
        }
        return true;
    }

    protected function insert($entity){
        $this->inserts[] = $entity;
        if($this->getStepSize() !== 0 && sizeof($this->inserts)>=$this->getStepSize()){
            $this->flushInserts();
        }
    }

    protected function flushInserts(){
        $count = count($this->inserts);
        if($count==0){
            return false;
        }
        foreach($this->inserts as $entity){
            $this->entityManager->persist($entity);
        }
        $this->entityManager->flush();
        foreach($this->inserts as $entity){
            $method = $this->getDbIdentifierGetter();
            $id = $entity->$method();
            $this->processedInsertIds[$id] = $id;
        }
        $this->entityManager->clear();
        $this->inserts = array();
        return $count;
    }

    protected function merge($existing, $new){
        $mappingAnnotations = $this->annotationReader->getMappingAnnotations($existing);
        foreach($mappingAnnotations as $propertyName => $typeAnnotation){
            $method = $typeAnnotation->getSetterName() ?: 'set'.ucfirst($propertyName);
            if(!method_exists($existing, $method)){
                throw new MethodNotFoundException('Method "'. $method .'" not found in "'. get_class($existing) .'"');
            }
            $getMethod = $typeAnnotation->getGetterName() ?: 'get'.ucfirst($propertyName);
            if(!method_exists($new, $getMethod)){
                throw new MethodNotFoundException('Method "'. $getMethod .'" not found in "'. get_class($existing) .'"');
            }

            $value = $new->$getMethod();

            if($value !== null && $value !== '' ){
                if( $value instanceof \DateTime &&  $existing->$getMethod() == $value ){
                    continue; //avoid unnecessary updates on DateTimes
                }
                $existing->$method($value);
            }
        }
        if(method_exists($new,'getData') && method_exists($existing, 'setData')){
            foreach($new->getData() as $key => $value){
                $existing->setData($key, $value);
            }
        }
        return $existing;
    }



    protected function loadIdentifiers($entity, $force = false)
    {
        if (count($this->identifiers) > 0 && !$force && get_class($entity) == $this->identifiersClass) {
           return;
        }
        $this->identifiersClass = get_class($entity);
        $identifierTypeAnnotations = $this->annotationReader->getIdentifierAnnotations($entity);
        $alias = $this->getAlias();
        $select = $alias.'.'.$this->getDbIdentifier().',';
        $qb = $this->entityManager->getRepository( $this->identifiersClass)->createQueryBuilder($alias);
        foreach ($identifierTypeAnnotations as $propertyName => $identifierAnnotation) {
            $select .= "$alias.$propertyName,";
            $this->identifiers[$propertyName] = array();
        }
        $select = substr($select, 0, -1);
        $qb->select($select);
        foreach ($qb->getQuery()->iterate() as $rows) {
            $row = array_shift($rows);
            foreach ($identifierTypeAnnotations as $propertyName => $identifierAnnotation) {
                $this->identifiers[$propertyName][$row[$propertyName]] = $row;
            }
        }

    }


    protected function getAlreadyExisting($entity)
    {
        $this->loadIdentifiers($entity);
        foreach($this->getIdentifiersForEntity($entity) as $propertyName => $searchValue){
            if(array_key_exists($searchValue,$this->identifiers[$propertyName])){
                return $this->identifiers[$propertyName][$searchValue];
            }
        }
        return false;
    }

    /**
     * @param string $alias
     */
    public function setAlias($alias)
    {
        $this->alias = $alias;
    }

    /**
     * @return string
     */
    public function getAlias()
    {
        return $this->alias;
    }

    /**
     * @param string $dbIdentifier
     */
    public function setDbIdentifier($dbIdentifier)
    {
        $this->dbIdentifier = $dbIdentifier;
    }

    /**
     * @return string
     */
    public function getDbIdentifier()
    {
        return $this->dbIdentifier;
    }

    /**
     * @param string $dbIdentifierGetter
     */
    public function setDbIdentifierGetter($dbIdentifierGetter)
    {
        $this->dbIdentifierGetter = $dbIdentifierGetter;
    }

    /**
     * @return string
     */
    public function getDbIdentifierGetter()
    {
        return $this->dbIdentifierGetter;
    }


    /**
     * @param array $inserts
     */
    public function setInserts($inserts)
    {
        $this->inserts = $inserts;
    }

    /**
     * @return array
     */
    public function getInserts()
    {
        return $this->inserts;
    }

    /**
     * @param array $updates
     */
    public function setUpdates($updates)
    {
        $this->updates = $updates;
    }

    /**
     * @return array
     */
    public function getUpdates()
    {
        return $this->updates;
    }

    /**
     * @param int $stepSize
     */
    public function setStepSize($stepSize)
    {
        $this->stepSize = $stepSize;
    }

    /**
     * @return int
     */
    public function getStepSize()
    {
        return $this->stepSize;
    }
}
